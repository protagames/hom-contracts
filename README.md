# Heroes Of Metaverse SmartContracts

Take a look on our [Coverage](https://protagames.github.io/smartcontracts/) report.

# ECR20 Custom mechanics

## Fees Overview
The company applies fees on each transaction. There are some fee mechanics coded and available to be configured, but their sum is set to a hard limit to avoid abuse by the company. The hard limit is 10%; in other words, even if the company is willing to set fees bigger than that limit, the code protects the holder.

## Temp Bans overview
All bans are temporary. The goal is to protect the typical user against some exploits. The temp ban has a hard limit that the company cannot change to further protect the users against abuse.

# Ecosystem Fee
- The company receives this fee to sustain and maintain its long-term operations. This fee aims to remove tokens from the circulant economy to monetize the company to make the business profitable and sustainable, ensuring the product's future development.

# Burn Fee
- This fee removes tokens from the current circulating supply permanently. It effectively burns the token in an irrecoverable manner, so the user or the company cannot rescue it.
- This fee behavior slowly causes deflation by taxing the transactions. Consequently, those who maintain their position will slowly see their assets increase in perceived value because of the artificial scarcity generated by this fee.
- This could be interpreted as a counter-measure to inflation caused by other economic mechanics such as tokens distribution from Play to Earn.

# Liquidity fee
- It is a fee taken used to increase the size of the DEX pool. In general, it works as follows:
1. Half of the liquidity fee tokens are sold at the current price on the DEX; in exchange, the contract receives native coins (BNB for Binance, ETH for Ethereum, Matic for Polygon, or others);
2. The contract now holds half of the value in tokens and the other half in native tokens. It uses both to add liquidity to the pool. At this moment, the DEX issues a deposit ticket as known as "LP Tokens" (Liquidity Pool Tokens).
3. The company reserves the right to decide where the LP Token goes. This setting is switchable between returning a token to the user in the form of cashback or transferring it to the company treasure.

# TimeLock DEX transactions
In order to reduce bot actions and serial trades, we chose to implement the measure to block the wallet from interacting with the DEX temporarily.
The contract protects the users from company abuse by checking against a hardcoded limit if the desirable time lock is acceptable.
The mechanic behind this implementation is that if the wallet can operate(not time-locked), it will lock further transactions in the wallet for a pre-determined time and allow the current transaction to continue; otherwise, it only blocks it.

# Anti dump measures
This measure protects the typical user against whales(users with a massive amount of tokens) from dumping(selling lots of tokens to the DEX).
The mechanics behind this consist of adding extra fees to punish dumping behavior. Before dumping, the contract checks the current amount of tokens the dex pool holds. If the amount of tokens a wallet wants to sell is above a configured percentage, it will apply extra fees to this transaction.
This mechanic used in conjunction with time lock gives more opportunities to the market to react to dump.
The company follows limits hardcoded in the contract to protect the users against abusive extra taxes and the threshold where this mechanic is activated.

# Tech Stuff

Try running some of the following tasks:

```shell
npx hardhat accounts
npx hardhat compile
npx hardhat clean
npx hardhat test
npx hardhat node
npx hardhat help
REPORT_GAS=true npx hardhat test
npx hardhat coverage
npx hardhat run scripts/deploy.ts
TS_NODE_FILES=true npx ts-node scripts/deploy.ts
npx eslint '**/*.{js,ts}'
npx eslint '**/*.{js,ts}' --fix
npx prettier '**/*.{json,sol,md}' --check
npx prettier '**/*.{json,sol,md}' --write
npx solhint 'contracts/**/*.sol'
npx solhint 'contracts/**/*.sol' --fix
```

# Etherscan verification

To try out Etherscan verification, you first need to deploy a contract to an Ethereum network that's supported by Etherscan, such as Ropsten.

In this project, copy the .env.example file to a file named .env, and then edit it to fill in the details. Enter your Etherscan API key, your Ropsten node URL (eg from Alchemy), and the private key of the account which will send the deployment transaction. With a valid .env file in place, first deploy your contract:

```shell
hardhat run --network ropsten scripts/sample-script.ts
```

Then, copy the deployment address and paste it in to replace `DEPLOYED_CONTRACT_ADDRESS` in this command:

```shell
npx hardhat verify --network ropsten DEPLOYED_CONTRACT_ADDRESS "Hello, Hardhat!"
```

# Performance optimizations

For faster runs of your tests and scripts, consider skipping ts-node's type checking by setting the environment variable `TS_NODE_TRANSPILE_ONLY` to `1` in hardhat's environment. For more details see [the documentation](https://hardhat.org/guides/typescript.html#performance-optimizations).
